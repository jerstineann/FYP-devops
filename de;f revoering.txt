#!/bin/bash

# Function to handle cleanup and exit
cleanup_and_exit() {
    exit $1
}

# Wait for MySQL server to start
until mysqladmin ping -h"$DB_HOST" -u"$DB_USER" -p"$DB_PASSWORD" &>/dev/null; do
    echo "Waiting for MySQL server..."
    sleep 2
done

# Function to check if a process is running
check_process() {
    PROCESS_NAME=$1
    if ! pgrep -x "$PROCESS_NAME" > /dev/null; then
        echo "$PROCESS_NAME is not running. Attempting to start..."
        # Start the process here (using the correct action for MySQL)
        if [ "$PROCESS_NAME" = "apache2" ]; then
            /opt/lampp/lampp startapache
        elif [ "$PROCESS_NAME" = "mysql" ]; then
            /opt/lampp/lampp startmysql
        else
            echo "Unknown process: $PROCESS_NAME"
        fi
    else
        echo "$PROCESS_NAME is running."
    fi
}


# Start Apache web server (optional, if not started automatically)
/opt/lampp/lampp startapache

# Start MySQL server (optional, if not started automatically)
/opt/lampp/lampp startmysql

# Start ProFTPD FTP server (optional, if not started automatically)
/opt/lampp/lampp startftp

# Keep the container running by executing a long-running command
tail -f /dev/null

# You can also perform cleanup actions when the container is stopped or exits
trap 'cleanup_and_exit $?' SIGTERM SIGINT

COPY docker-entrypoint.sh /docker-entrypoint.sh
RUN chmod +x /docker-entrypoint.sh




curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"

install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
kubectl version --client


curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb
sudo dpkg -i minikube_latest_amd64.deb

root@FYP-SR2289:/home/dockeradm/Downloads# minikube start --force
ğŸ˜„  minikube v1.23.2 on Ubuntu 18.04
â—  minikube skips various validations when --force is supplied; this may lead to unexpected behavior
âœ¨  Automatically selected the docker driver. Other choices: ssh, none
ğŸ›‘  The "docker" driver should not be used with root privileges.
ğŸ’¡  If you are running minikube within a VM, consider using --driver=none:
ğŸ“˜    https://minikube.sigs.k8s.io/docs/reference/drivers/none/
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸšœ  Pulling base image ...
ğŸ¤¦  StartHost failed, but will try again: boot lock: unable to open /tmp/juju-mke11f63b5835bf422927bf558fccac7a21a838f: permission denied
ğŸ˜¿  Failed to start docker container. Running "minikube delete" may fix it: boot lock: unable to open /tmp/juju-mke11f63b5835bf422927bf558fccac7a21a838f: permission denied

âŒ  Exiting due to HOST_JUJU_LOCK_PERMISSION: Failed to start host: boot lock: unable to open /tmp/juju-mke11f63b5835bf422927bf558fccac7a21a838f: permission denied
ğŸ’¡  Suggestion: Run 'sudo sysctl fs.protected_regular=0', or try a driver which does not require root, such as '--driver=docker'
ğŸ¿  Related issue: https://github.com/kubernetes/minikube/issues/6391


kubectl run web --image=divya120/web
 kubectl run db --image=divya120/db

kubectl apply -f db-deployment.yaml
kubectl apply -f deployment.yaml

kubectl apply -f web-service.yaml
kubectl apply -f db-service.yaml

kubectl get deployments

minikube service web-service --url


kubectl delete services web-service
kubectl delete deployments web
kubectl delete pods web
docker rmi web
docker rmi divya120/web

